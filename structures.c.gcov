        -:    0:Source:src/structures.c
        -:    0:Programs:2
        -:    1:#include <stdlib.h>
        -:    2:#include <stdio.h>
        -:    3:#include <unistd.h>
        -:    4:#include <stdbool.h>
        -:    5:#include <errno.h>
        -:    6:
        -:    7:#include "structures.h"
        -:    8:
        -:    9:#define EXIT_FAIL -1
        -:   10:
        -:   11:/**
        -:   12: * @def GRUMBLE(msg)
        -:   13: *
        -:   14: * @brief Grumbles and exits
        -:   15: * @details Checks for a system call error via errno.
        -:   16: * If there was one, it uses perror. 
        -:   17: * Otherwise, it prints to stderr and exits.
        -:   18: * 
        -:   19: * This is to make sure that if you choose to grumble after 
        -:   20: * something that didn't create an errno, 
        -:   21: * you don't end up writing "Error: Success !" in your output.
        -:   22: *
        -:   23: * @param msg Error message
        -:   24: */
        -:   25:#define GRUMBLE(msg)                                       \
        -:   26:	if (errno){                                            \
        -:   27:		perror(msg);                                       \
        -:   28:	}                                                      \
        -:   29:	else{                                                  \
        -:   30:		fprintf(stderr, "%s\n", msg);                      \
        -:   31:	}                                                      \
        -:   32:	exit(EXIT_FAILURE);
        -:   33:
        -:   34:/**
        -:   35: * @def ALLOC_NULL(alloc, msg, ptr, OPERATION)
        -:   36: *
        -:   37: * @brief Checks if the malloc function didi not fail.
        -:   38: * @brief If so, free, grumble and exits.
        -:   39: * 
        -:   40: * @param alloc the return pointer of a malloc
        -:   41: * @param msg Error pessage
        -:   42: * @param ptr a pointer to check if is NULL or not
        -:   43: * @param OPERATION can be an instruction, a fonction or a macro
        -:   44: */
        -:   45:#define ALLOC_NULL(alloc, msg, ptr, OPERATION)             \
        -:   46:	if (alloc == NULL){                                    \
        -:   47:		if (ptr == NULL){                                  \
        -:   48:			GRUMBLE(msg)                                   \
        -:   49:		}                                                  \
        -:   50:		else{                                              \
        -:   51:			OPERATION;                                     \
        -:   52:			GRUMBLE(msg)                                   \
        -:   53:		}                                                  \
        -:   54:	}
        -:   55:
        -:   56:/**
        -:   57: * @def ASSERT(val, OPERATION)
        -:   58: *
        -:   59: * @brief Checks if val is -1. If so, call OPERATION.
        -:   60: * 
        -:   61: * @param val int
        -:   62: * @param OPERATION can be an instruction, a fonction or a macro
        -:   63: */
        -:   64:#define ASSERT(val, OPERATION)                             \
        -:   65:	if (val == -1){                                        \
        -:   66:		OPERATION;                                         \
        -:   67:	}
        -:   68:
        -:   69:/**
        -:   70: * @def CHECK_NULL(ptr, OPERATION)
        -:   71: *
        -:   72: * @brief Checks if ptr is NULL. If so, call OPERATION.
        -:   73: * 
        -:   74: * @param ptr a pointer
        -:   75: * @param OPERATION can be an instruction, a fonction or a macro
        -:   76: */
        -:   77:#define CHECK_NULL(ptr, OPERATION)                         \
        -:   78:	if (ptr == NULL){                                      \
        -:   79:		OPERATION;                                         \
        -:   80:	}
        -:   81:
        -:   82:/**
        -:   83: * @def CHECK_ZERO(val, OPERATION)
        -:   84: *
        -:   85: * @brief Checks if val is 0. If so, call OPERATION.
        -:   86: * 
        -:   87: * @param val int
        -:   88: * @param OPERATION can be an instruction, a fonction or a macro
        -:   89: */
        -:   90:#define CHECK_ZERO(val, OPERATION)                         \
        -:   91:	if (val == 0){                                         \
        -:   92:		OPERATION;                                         \
        -:   93:	}
        -:   94:
        -:   95:
       13:   96:void buff_free(Buffer* b){
       13:   97:	if (b != NULL && b->start != NULL){
        -:   98:		
       13:   99:		node* cur = b->start;
   327707:  100:		while (cur->next != NULL){
   327681:  101:			if (cur->prec)
   327678:  102:				free(cur->prec);
        -:  103:
   327681:  104:			free(cur->mem);
   327681:  105:			cur = cur->next;
        -:  106:		}
       13:  107:		free(cur->prec);
       13:  108:		free(cur->mem);
       13:  109:		free(cur);
       13:  110:		free(b);
        -:  111:	}
        -:  112:
       13:  113:	return;
        -:  114:}
        -:  115:
   327697:  116:node* node_new(){
        -:  117:	node* n;
   327697:  118:	ALLOC_NULL((n = malloc(sizeof(struct s_node))),
        -:  119:			"malloc of node", NULL, free(NULL));
        -:  120:
   327697:  121:	ALLOC_NULL((n->mem = malloc(sizeof(s) * BUFF_SIZE)),
        -:  122:			"malloc in node", n, free(n))
        -:  123:
   327697:  124:	n->size = BUFF_SIZE;
   327697:  125:	n->prec = NULL;
   327697:  126:	n->next = NULL;
   327697:  127:	n->readAddr = 0;
   327697:  128:	n->writeAddr = 0;
        -:  129:
   327697:  130:	return n;
        -:  131:}
        -:  132:
       16:  133:Buffer* buff_new(){
        -:  134:	Buffer* b;
       16:  135:	ALLOC_NULL((b = malloc(sizeof(struct s_buff))),
        -:  136:			"malloc of buffer", NULL, buff_free(NULL))
        -:  137:
       16:  138:	b->readNode = node_new();
       16:  139:	b->writeNode = b->readNode;
       16:  140:	b->start = b->readNode;
        -:  141:
       16:  142:	return b;
        -:  143:}
        -:  144:
134218209:  145:int buff_putc(Buffer* b, char c){
134218209:  146:	CHECK_NULL(b, return EXIT_FAIL)
134218209:  147:	CHECK_NULL(b->writeNode, return EXIT_FAIL)
        -:  148:
        -:  149:	// If there's no more room in the node,
134218209:  150:	if (b->writeNode->writeAddr >= b->writeNode->size){
        -:  151:		// Create a new node, link this node to it
   524288:  152:		if (b->writeNode->next == NULL){
   327681:  153:			b->writeNode->next = node_new();
   327681:  154:			b->writeNode->next->prec = b->writeNode;
        -:  155:		}
        -:  156:		// Link the new node to the current
        -:  157:		// Hop to the next node
   524288:  158:		b->writeNode = b->writeNode->next;
        -:  159:	}
        -:  160:
134218209:  161:	b->writeNode->mem[b->writeNode->writeAddr++] = c;
134218209:  162:	return EXIT_SUCCESS;
        -:  163:}
        -:  164:
       57:  165:int buff_print(Buffer* b){
       57:  166:	CHECK_NULL(b, return EXIT_FAIL) 
        -:  167:
        -:  168:	// Visit each node of the list from the beginning and write it
       57:  169:	node* cur = b->start;
   524459:  170:	while (cur != NULL){
   524345:  171:		ASSERT(write(1, cur->mem, cur->writeAddr), return EXIT_FAIL)
   524345:  172:		cur = cur->next;
        -:  173:	}
        -:  174:
       57:  175:	return EXIT_SUCCESS;
        -:  176:}
        -:  177:
134742477:  178:s buff_getc(Buffer* b){
134742477:  179:	CHECK_NULL(b, return EOF)
134742477:  180:	CHECK_NULL(b->readNode, return EOF)
        -:  181:
        -:  182:	// If we're at the end of our node
134742477:  183:	if (b->readNode->readAddr >= b->readNode->size){
        -:  184:		// And there is more
   524288:  185:		if (b->readNode->next){
        -:  186:			// We pick the next node and call ourselves again
   524268:  187:			b->readNode = b->readNode->next;
   524268:  188:			return buff_getc(b);
        -:  189:		}
        -:  190:		else {
       20:  191:			return EOF;
        -:  192:		}
        -:  193:	}
        -:  194:
134218189:  195:	return b->readNode->mem[b->readNode->readAddr++];
        -:  196:}
        -:  197:
       67:  198:s buff_unputc(Buffer* b){
       67:  199:	CHECK_NULL(b, return EOF)
       67:  200:	CHECK_NULL(b->writeNode, return EOF)
        -:  201:
        -:  202:	// If we're at the start of our node
       67:  203:	CHECK_ZERO(b->writeNode->writeAddr, return EOF)
        -:  204:
        -:  205:	/*
        -:  206:		// This is correct because of buff_putc's behaviour
        -:  207:		// 
        -:  208:		// Indeed, writeAddr will never be 0 unless we're at the absolute
        -:  209:		// start of the buffer. It skips 0. It goes from 255 to 256, which
        -:  210:		// is out of bounds, detects that 256 is out of bounds, changes node,
        -:  211:		// then writes at 0 in the next and sets writeAddr to 1.
        -:  212:		// So, a mere --writeAddr is always enough !
        -:  213:
        -:  214:		if (b->writeNode->prec){
        -:  215:			b->writeNode = b->writeNode->prec;
        -:  216:			return buff_unputc(b);
        -:  217:		}
        -:  218:	//*/
        -:  219:
       67:  220:	return b->writeNode->mem[--b->writeNode->writeAddr];
        -:  221:}
        -:  222:
       67:  223:void buff_reset(Buffer* b){
       67:  224:	if (b != NULL){
       67:  225:		b->readNode = b->start;
       67:  226:		b->writeNode = b->start;
        -:  227:
        -:  228:		// Go through each node and reset it
       67:  229:		node* cur = b->start;
   196808:  230:		while (cur != NULL){
   196674:  231:			cur->readAddr = 0;
   196674:  232:			cur->writeAddr = 0;
   196674:  233:			cur = cur->next;
        -:  234:		}
        -:  235:	}
       67:  236:}
        -:  237:
       67:  238:sFile* my_open(int fd){	
        -:  239:	sFile* f;
       67:  240:	ALLOC_NULL((f = malloc(sizeof(struct s_file))),
        -:  241:			"malloc of file", NULL, my_close(NULL))
        -:  242:
       67:  243:	ALLOC_NULL((f->buffer = malloc(BUFFER_SIZE * sizeof(char))),
        -:  244:			"malloc in file", f, my_close(f))
        -:  245:	//f->mode = mode[0];
       67:  246:	f->length = 0;
       67:  247:	f->index = 0;
       67:  248:	f->fd = fd;
        -:  249:
       67:  250:	return f;
        -:  251:}
        -:  252:
134218209:  253:char my_getc(sFile* f){
134218209:  254:	if(f->length == 0 || f->index >= f->length){
   524384:  255:		f->length = read(f->fd, f->buffer, BUFFER_SIZE);
   524384:  256:		f->index = 0;
   524384:  257:		ASSERT(f->length, return EXIT_FAIL);
   524384:  258:		CHECK_ZERO(f->length, return EOF);
        -:  259:	}
134218142:  260:	return f->buffer[f->index++];
        -:  261:}
        -:  262:
       67:  263:int my_close(sFile* f){
       67:  264:	CHECK_NULL(f, return EXIT_FAIL)
        -:  265:
       67:  266:	free(f->buffer);
       67:  267:	free(f);
       67:  268:	return 0;
        -:  269:}
        -:  270:
