        -:    0:Source:src/buff_and_file.c
        -:    0:Programs:3
        -:    1:#include <stdlib.h>
        -:    2:#include <stdio.h>
        -:    3:#include <unistd.h>
        -:    4:#include <stdbool.h>
        -:    5:#include <errno.h>
        -:    6:
        -:    7:#include "buff_and_file.h"
        -:    8:#include "assert.h"
        -:    9:
        -:   10:#define EXIT_FAIL -1
        -:   11:
        -:   12:// Small 'if' to avoid the "Error: Success" problem
        -:   13:#define GRUMBLE(msg)                                       \
        -:   14:	if (errno){                                            \
        -:   15:		perror(msg);                                       \
        -:   16:	}                                                      \
        -:   17:	else{                                                  \
        -:   18:		fprintf(stderr, "%s\n", msg);                      \
        -:   19:	}                                                      \
        -:   20:	exit(EXIT_FAILURE);
        -:   21:
        -:   22:#define ALLOC_NULL(alloc, msg, n, OPERATION)               \
        -:   23:	if (alloc == NULL){                                    \
        -:   24:		if (n == NULL){                                    \
        -:   25:			GRUMBLE(msg)                                   \
        -:   26:		}                                                  \
        -:   27:		else{                                              \
        -:   28:			OPERATION;                                     \
        -:   29:			GRUMBLE(msg)                                   \
        -:   30:		}                                                  \
        -:   31:	}
        -:   32:
        -:   33:#define CHECK_VAL(a, val, OPERATION)                       \
        -:   34:	if (a == val){                                         \
        -:   35:		OPERATION;                                         \
        -:   36:	}
        -:   37:
        -:   38:
       13:   39:void buff_free(Buffer* b){
       13:   40:	if (b != NULL){
       13:   41:		node* cur = b->start;
   327720:   42:		while (cur != NULL){
   327694:   43:			free(cur->mem);
   327694:   44:			cur = cur->next;
        -:   45:			//printf("\n%p -> %p -> %p", cur->prec, cur, cur->next);
   327694:   46:			if (cur)
   327681:   47:				free(cur->prec);
        -:   48:		}
       13:   49:		free(cur);
       13:   50:		free(b);
        -:   51:	}
        -:   52:
       13:   53:	return;
        -:   54:}
        -:   55:
   327696:   56:node* node_new(){
        -:   57:	node* n;
   327696:   58:	ALLOC_NULL((n = malloc(sizeof(struct s_node))),
        -:   59:			"malloc of node", NULL, free(NULL));
        -:   60:
   327696:   61:	ALLOC_NULL((n->mem = malloc(sizeof(s) * BUFF_SIZE)),
        -:   62:			"malloc in node", n, free(n))
        -:   63:
   327696:   64:	n->size = BUFF_SIZE;
   327696:   65:	n->prec = NULL;
   327696:   66:	n->next = NULL;
   327696:   67:	n->readAddr = 0;
   327696:   68:	n->writeAddr = 0;
        -:   69:
   327696:   70:	return n;
        -:   71:}
        -:   72:
       15:   73:Buffer* buff_new(){
        -:   74:	Buffer* b;
       15:   75:	ALLOC_NULL((b = malloc(sizeof(struct s_buff))),
        -:   76:			"malloc of buffer", NULL, buff_free(NULL))
        -:   77:
       15:   78:	b->readNode = node_new();
       15:   79:	b->writeNode = b->readNode;
       15:   80:	b->start = b->readNode;
        -:   81:
       15:   82:	return b;
        -:   83:}
        -:   84:
134218210:   85:int buff_putc(Buffer* b, char c){
134218210:   86:	CHECK_VAL(b, NULL, return EXIT_FAIL)
134218210:   87:	CHECK_VAL(b->writeNode, NULL, return EXIT_FAIL)
        -:   88:
        -:   89:	// If there's no more room in the node,
134218210:   90:	if (b->writeNode->writeAddr >= b->writeNode->size){
        -:   91:		// Create a new node, link this node to it
   524288:   92:		if (b->writeNode->next == NULL){
   327681:   93:			b->writeNode->next = node_new();
   327681:   94:			b->writeNode->next->prec = b->writeNode;
        -:   95:		}
        -:   96:		// Link the new node to the current
        -:   97:		// Hop to the next node
   524288:   98:		b->writeNode = b->writeNode->next;
        -:   99:	}
        -:  100:
134218210:  101:	b->writeNode->mem[b->writeNode->writeAddr++] = c;
134218210:  102:	return EXIT_SUCCESS;
        -:  103:}
        -:  104:
       57:  105:int buff_print(Buffer* b){
       57:  106:	CHECK_VAL(b, NULL, return EXIT_FAIL) 
        -:  107:
        -:  108:	// Visit each node of the list from the beginning and write it
       57:  109:	node* cur = b->start;
   524459:  110:	while (cur != NULL){
   524345:  111:		CHECK_VAL(write(1, cur->mem, cur->writeAddr),
        -:  112:				EXIT_FAIL, return EXIT_FAIL)
   524345:  113:		cur = cur->next;
        -:  114:	}
        -:  115:
       57:  116:	return EXIT_SUCCESS;
        -:  117:}
        -:  118:
134742479:  119:s buff_getc(Buffer* b){
134742479:  120:	CHECK_VAL(b, NULL, return EOF)
134742479:  121:	CHECK_VAL(b->readNode, NULL, return EOF)
        -:  122:
        -:  123:	// If we're at the end of our node
134742479:  124:	if (b->readNode->readAddr >= b->readNode->size){
        -:  125:		// And there is more
   524289:  126:		if (b->readNode->next){
        -:  127:			// We pick the next node and call ourselves again
   524269:  128:			b->readNode = b->readNode->next;
   524269:  129:			return buff_getc(b);
        -:  130:		}
        -:  131:		else {
       20:  132:			return EOF;
        -:  133:		}
        -:  134:	}
        -:  135:
134218190:  136:	return b->readNode->mem[b->readNode->readAddr++];
        -:  137:}
        -:  138:
       67:  139:s buff_unputc(Buffer* b){
       67:  140:	CHECK_VAL(b, NULL, return EOF)
       67:  141:	CHECK_VAL(b->writeNode, NULL, return EOF)
        -:  142:
        -:  143:	// If we're at the start of our node
       67:  144:	if (b->writeNode->writeAddr == 0){
    #####:  145:		return EOF;
        -:  146:	/*
        -:  147:		// This is correct because of buff_putc's behaviour
        -:  148:		// 
        -:  149:		// Indeed, writeAddr will never be 0 unless we're at the absolute
        -:  150:		// start of the buffer. It skips 0. It goes from 255 to 256, which
        -:  151:		// is out of bounds, detects that 256 is out of bounds, changes node,
        -:  152:		// then writes at 0 in the next and sets writeAddr to 1.
        -:  153:		// So, a mere --writeAddr is always enough !
        -:  154:
        -:  155:		if (b->writeNode->prec){
        -:  156:			b->writeNode = b->writeNode->prec;
        -:  157:			return buff_unputc(b);
        -:  158:		}
        -:  159:	//*/
        -:  160:	}
       67:  161:	return b->writeNode->mem[--b->writeNode->writeAddr];
        -:  162:}
        -:  163:
       67:  164:void buff_reset(Buffer* b){
       67:  165:	if (b != NULL){
       67:  166:		b->readNode = b->start;
       67:  167:		b->writeNode = b->start;
        -:  168:
        -:  169:		// Go through each node and reset it
       67:  170:		node* cur = b->start;
   196808:  171:		while (cur != NULL){
   196674:  172:			cur->readAddr = 0;
   196674:  173:			cur->writeAddr = 0;
   196674:  174:			cur = cur->next;
        -:  175:		}
        -:  176:	}
       67:  177:}
        -:  178:
       67:  179:sFile* my_open(int fd){	
        -:  180:	sFile* f;
       67:  181:	ALLOC_NULL((f = malloc(sizeof(struct s_file))),
        -:  182:			"malloc of file", NULL, my_close(NULL))
        -:  183:
       67:  184:	ALLOC_NULL((f->buffer = malloc(BUFFER_SIZE * sizeof(char))),
        -:  185:			"malloc in file", f, my_close(NULL))
        -:  186:	//f->mode = mode[0];
       67:  187:	f->length = 0;
       67:  188:	f->index = 0;
       67:  189:	f->fd = fd;
        -:  190:
       67:  191:	return f;
        -:  192:}
        -:  193:
134218210:  194:char my_getc(sFile* f){
134218210:  195:	if(f->length == 0 || f->index >= f->length){
   524385:  196:		f->length = read(f->fd, f->buffer, BUFFER_SIZE);
   524385:  197:		f->index = 0;
   524385:  198:		CHECK_VAL(f->length, EXIT_FAIL, return EXIT_FAIL);
   524385:  199:		CHECK_VAL(f->length, 0, return EOF);
        -:  200:	}
134218143:  201:	return f->buffer[f->index++];
        -:  202:}
        -:  203:
       67:  204:int my_close(sFile* f){
       67:  205:	CHECK_VAL(f, NULL, return EXIT_FAIL)
        -:  206:
       67:  207:	free(f->buffer);
       67:  208:	free(f);
       67:  209:	return 0;
        -:  210:}
        -:  211:
