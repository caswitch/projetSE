        -:    0:Source:src/buff_and_file.c
        -:    0:Programs:3
        -:    1:#include <stdlib.h>
        -:    2:#include <stdio.h>
        -:    3:#include <unistd.h>
        -:    4:#include <stdbool.h>
        -:    5:#include <errno.h>
        -:    6:
        -:    7:#include "buff_and_file.h"
        -:    8:#include "assert.h"
        -:    9:
        -:   10:#define EXIT_FAIL -1
        -:   11:
        -:   12:// Small 'if' to avoid the "Error: Success" problem
        -:   13:#define GRUMBLE(msg)                                       \
        -:   14:	if (errno){                                            \
        -:   15:		perror(msg);                                       \
        -:   16:	}                                                      \
        -:   17:	else{                                                  \
        -:   18:		fprintf(stderr, "%s\n", msg);                      \
        -:   19:	}                                                      \
        -:   20:	exit(EXIT_FAILURE);
        -:   21:
        -:   22:#define ALLOC_NULL(alloc, msg, n, OPERATION)               \
        -:   23:	if (alloc == NULL){                                    \
        -:   24:		if (n == NULL){                                    \
        -:   25:			GRUMBLE(msg)                                   \
        -:   26:		}                                                  \
        -:   27:		else{                                              \
        -:   28:			OPERATION;                                     \
        -:   29:			GRUMBLE(msg)                                   \
        -:   30:		}                                                  \
        -:   31:	}
        -:   32:
        -:   33:#define PTR_NULL(ptr, val)                                 \
        -:   34:	if (ptr == NULL){                                      \
        -:   35:		return val;                                        \
        -:   36:	}
        -:   37:
        -:   38:#define CHECK_VAL(a, val, ret)                                 \
        -:   39:	if (a == val){                                         \
        -:   40:		return ret;                                        \
        -:   41:	}
        -:   42:
        -:   43:
       13:   44:void buff_free(Buffer* b){
       13:   45:	if (b != NULL){
       13:   46:		node* cur = b->start;
   327720:   47:		while (cur != NULL){
   327694:   48:			free(cur->mem);
   327694:   49:			cur = cur->next;
        -:   50:			//printf("\n%p -> %p -> %p", cur->prec, cur, cur->next);
   327694:   51:			if (cur)
   327681:   52:				free(cur->prec);
        -:   53:		}
       13:   54:		free(cur);
       13:   55:		free(b);
        -:   56:	}
        -:   57:
       13:   58:	return;
        -:   59:}
        -:   60:
   327696:   61:node* node_new(){
        -:   62:	node* n;
   327696:   63:	ALLOC_NULL((n = malloc(sizeof(struct s_node))),
        -:   64:			"malloc of node", NULL, free(NULL));
        -:   65:
   327696:   66:	ALLOC_NULL((n->mem = malloc(sizeof(s) * BUFF_SIZE)),
        -:   67:			"malloc in node", n, free(n))
        -:   68:
   327696:   69:	n->size = BUFF_SIZE;
   327696:   70:	n->prec = NULL;
   327696:   71:	n->next = NULL;
   327696:   72:	n->readAddr = 0;
   327696:   73:	n->writeAddr = 0;
        -:   74:
   327696:   75:	return n;
        -:   76:}
        -:   77:
       15:   78:Buffer* buff_new(){
        -:   79:	Buffer* b;
       15:   80:	ALLOC_NULL((b = malloc(sizeof(struct s_buff))),
        -:   81:			"malloc of buffer", NULL, buff_free(NULL))
        -:   82:
       15:   83:	b->readNode = node_new();
       15:   84:	b->writeNode = b->readNode;
       15:   85:	b->start = b->readNode;
        -:   86:
       15:   87:	return b;
        -:   88:}
        -:   89:
134218210:   90:int buff_putc(Buffer* b, char c){
134218210:   91:	PTR_NULL(b, EXIT_FAIL)
134218210:   92:	PTR_NULL(b->writeNode, EXIT_FAIL)
        -:   93:
        -:   94:	// If there's no more room in the node,
134218210:   95:	if (b->writeNode->writeAddr >= b->writeNode->size){
        -:   96:		// Create a new node, link this node to it
   524288:   97:		if (b->writeNode->next == NULL){
   327681:   98:			b->writeNode->next = node_new();
   327681:   99:			b->writeNode->next->prec = b->writeNode;
        -:  100:		}
        -:  101:		// Link the new node to the current
        -:  102:		// Hop to the next node
   524288:  103:		b->writeNode = b->writeNode->next;
        -:  104:	}
        -:  105:
134218210:  106:	b->writeNode->mem[b->writeNode->writeAddr++] = c;
134218210:  107:	return EXIT_SUCCESS;
        -:  108:}
        -:  109:
       57:  110:int buff_print(Buffer* b){
       57:  111:	PTR_NULL(b, EXIT_FAIL) 
        -:  112:
        -:  113:	// Visit each node of the list from the beginning and write it
       57:  114:	node* cur = b->start;
   524459:  115:	while (cur != NULL){
   524345:  116:		CHECK_VAL(write(1, cur->mem, cur->writeAddr),
        -:  117:				EXIT_FAIL, EXIT_FAIL)
   524345:  118:		cur = cur->next;
        -:  119:	}
        -:  120:
       57:  121:	return EXIT_SUCCESS;
        -:  122:}
        -:  123:
134742479:  124:s buff_getc(Buffer* b){
134742479:  125:	PTR_NULL(b, EOF)
134742479:  126:	PTR_NULL(b->readNode, EOF)
        -:  127:
        -:  128:	// If we're at the end of our node
134742479:  129:	if (b->readNode->readAddr >= b->readNode->size){
        -:  130:		// And there is more
   524289:  131:		if (b->readNode->next){
        -:  132:			// We pick the next node and call ourselves again
   524269:  133:			b->readNode = b->readNode->next;
   524269:  134:			return buff_getc(b);
        -:  135:		}
        -:  136:		else {
       20:  137:			return EOF;
        -:  138:		}
        -:  139:	}
        -:  140:
134218190:  141:	return b->readNode->mem[b->readNode->readAddr++];
        -:  142:}
        -:  143:
       67:  144:s buff_unputc(Buffer* b){
       67:  145:	PTR_NULL(b, EOF)
       67:  146:	PTR_NULL(b->writeNode, EOF)
        -:  147:
        -:  148:	// If we're at the start of our node
       67:  149:	if (b->writeNode->writeAddr == 0){
        -:  150:		// We pick the last one and call ourselves again
    #####:  151:		b->writeNode = b->writeNode->prec;
    #####:  152:		return buff_unputc(b);
        -:  153:	}
        -:  154:
        -:  155:	//printf("%d/%d\n", b->writeNode->writeAddr, b->writeNode->size);
       67:  156:	return b->writeNode->mem[b->writeNode->writeAddr--];
        -:  157:}
        -:  158:
       67:  159:void buff_reset(Buffer* b){
       67:  160:	if (b != NULL){
       67:  161:		b->readNode = b->start;
       67:  162:		b->writeNode = b->start;
        -:  163:
        -:  164:		// Go through each node and reset it
       67:  165:		node* cur = b->start;
   196808:  166:		while (cur != NULL){
   196674:  167:			cur->readAddr = 0;
   196674:  168:			cur->writeAddr = 0;
   196674:  169:			cur = cur->next;
        -:  170:		}
        -:  171:	}
       67:  172:}
        -:  173:
       67:  174:sFile* my_open(int fd){	
        -:  175:	sFile* f;
       67:  176:	ALLOC_NULL((f = malloc(sizeof(struct s_file))),
        -:  177:			"malloc of file", NULL, my_close(NULL))
        -:  178:
       67:  179:	ALLOC_NULL((f->buffer = malloc(BUFFER_SIZE * sizeof(char))),
        -:  180:			"malloc in file", f, my_close(NULL))
        -:  181:	//f->mode = mode[0];
       67:  182:	f->length = 0;
       67:  183:	f->index = 0;
       67:  184:	f->fd = fd;
        -:  185:
       67:  186:	return f;
        -:  187:}
        -:  188:
134218210:  189:char my_getc(sFile* f){
134218210:  190:	if(f->length == 0 || f->index >= f->length){
   524385:  191:		f->length = read(f->fd, f->buffer, BUFFER_SIZE);
   524385:  192:		f->index = 0;
   524385:  193:		CHECK_VAL(f->length, EXIT_FAIL, EXIT_FAIL);
   524385:  194:		CHECK_VAL(f->length, 0, EOF);
        -:  195:	}
134218143:  196:	return f->buffer[f->index++];
        -:  197:}
        -:  198:
       67:  199:int my_close(sFile* f){
       67:  200:	PTR_NULL(f, EXIT_FAIL)
        -:  201:
       67:  202:	free(f->buffer);
       67:  203:	free(f);
       67:  204:	return 0;
        -:  205:}
        -:  206:
